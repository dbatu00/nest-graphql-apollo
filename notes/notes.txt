// TypeScript
@Column({ nullable: true })                     // TypeORM → DB allows NULL
@Field(() => String, { nullable: true })        // GraphQL → API allows null
nickname?: string | null;                       // TS → property optional, can be null


2. Why not allow types at field level?

Several reasons:

Single type check per operation

All type checking happens at the operation entry point.

If you declared types inside fields, the server would have to recursively type-check every field — unnecessarily complicated and inconsistent.

Variables are reusable

You can pass the same variable to multiple fields:

query ($id: Int!) { // operation level
  getUser(id: $id) { id, name }//field level
  getPosts(authorId: $id) { title }
}


If types were defined at the field level, sharing variables across fields would be impossible.

Cleaner API contract

The operation signature (query ($id: Int!)) tells clients exactly what they must provide.

Field arguments just use those variables — no type ambiguity.